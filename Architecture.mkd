# The Architecture of Void

## User Interface and Architectural Layers
The core logic will be written in F# that is ignorant of view/UI implementation
details. The view/UI code will be written in C#.

The view code should absorb the complexity of the translation between F# and C#
and especially of the translation between Void's model of the view and the GUI
library's model of the view.

The UI/View is to handle all logic which is closely coupled with the
implementation details of the UI, but not its conceptual model, such as the
details of a particular graphics library. The view model is to model the UI.
However, this model is conceptually different than the total current state of
the editor (in other words, there is not a one-to-one between everything in the
editor's state and the screen, or everything on the screen and the editor's
state). The model and view model should be written functionally, except what we
are currently calling the "controllers" (this may need to be renamed to
"handlers" or something else once we understand it better), which are the
imperative "glue" in the view model that ties together view, model, and view
model. Their only concern is to connect the other components; they should be
light on logic and heavy on delegation. The models should not reference their
controllers.

Loose coupling is to be maintained by the use of commands and events. The view
model should be generated from events off the core model. It should not make
direct calls to the core model.

## Questions
+ Should the view send down events rather than just directly calling methods on
  controllers?
+ To what extent and in what way should the `MainController` broker? Should it
  pass all commands to all controllers, similar to what it is doing with events
  now?

## Other
Pending, but will imitate VsVim and other known good patterns.
